/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { ScreenshothisCore } from "../core.js";
import { encodeFormQuery } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { ScreenshothisError } from "../models/errors/screenshothiserror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

export enum TakeAcceptEnum {
  imageJpeg = "image/jpeg",
  imagePng = "image/png",
  imageWebp = "image/webp",
}

/**
 * Generate optimized website screenshot
 *
 * @remarks
 * Captures high-quality screenshots of websites with advanced optimization features including smart caching, CDN integration, request deduplication, and quota management. Supports multiple image formats (JPEG, PNG, WebP) with customizable dimensions, device emulation, and viewport settings. Implements efficient S3 streaming for large images and conditional requests for optimal performance.
 */
export function screenshotsTake(
  client: ScreenshothisCore,
  request: operations.TakeScreenshotRequest,
  options?: RequestOptions & { acceptHeaderOverride?: TakeAcceptEnum },
): APIPromise<
  Result<
    operations.TakeScreenshotResponse | undefined,
    | errors.ForbiddenError
    | errors.InternalServerError
    | ScreenshothisError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: ScreenshothisCore,
  request: operations.TakeScreenshotRequest,
  options?: RequestOptions & { acceptHeaderOverride?: TakeAcceptEnum },
): Promise<
  [
    Result<
      operations.TakeScreenshotResponse | undefined,
      | errors.ForbiddenError
      | errors.InternalServerError
      | ScreenshothisError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) => operations.TakeScreenshotRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const path = pathToFunc("/v1/screenshots/take")();

  const query = encodeFormQuery({
    "api_key": payload.api_key,
    "block_ads": payload.block_ads,
    "block_cookie_banners": payload.block_cookie_banners,
    "block_requests": payload.block_requests,
    "block_resources": payload.block_resources,
    "block_trackers": payload.block_trackers,
    "bypass_csp": payload.bypass_csp,
    "cache_key": payload.cache_key,
    "cache_ttl": payload.cache_ttl,
    "cookies": payload.cookies,
    "device_scale_factor": payload.device_scale_factor,
    "format": payload.format,
    "full_page": payload.full_page,
    "full_page_scroll": payload.full_page_scroll,
    "full_page_scroll_duration": payload.full_page_scroll_duration,
    "has_touch": payload.has_touch,
    "headers": payload.headers,
    "height": payload.height,
    "is_cached": payload.is_cached,
    "is_landscape": payload.is_landscape,
    "is_mobile": payload.is_mobile,
    "prefers_color_scheme": payload.prefers_color_scheme,
    "prefers_reduced_motion": payload.prefers_reduced_motion,
    "quality": payload.quality,
    "selector": payload.selector,
    "url": payload.url,
    "user_agent": payload.user_agent,
    "width": payload.width,
  });

  const headers = new Headers(compactMap({
    Accept: options?.acceptHeaderOverride
      || "image/jpeg;q=1, image/png;q=0.7, image/webp;q=0",
  }));

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "takeScreenshot",
    oAuth2Scopes: [],

    resolvedSecurity: null,

    securitySource: null,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 500,
          maxInterval: 60000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["5XX"],
  };

  const requestRes = client._createRequest(context, {
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["403", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.TakeScreenshotResponse | undefined,
    | errors.ForbiddenError
    | errors.InternalServerError
    | ScreenshothisError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.stream(200, operations.TakeScreenshotResponse$inboundSchema.optional(), {
      ctype: "image/jpeg",
    }),
    M.stream(200, operations.TakeScreenshotResponse$inboundSchema.optional(), {
      ctype: "image/png",
    }),
    M.stream(200, operations.TakeScreenshotResponse$inboundSchema.optional(), {
      ctype: "image/webp",
    }),
    M.nil(304, operations.TakeScreenshotResponse$inboundSchema.optional()),
    M.jsonErr(403, errors.ForbiddenError$inboundSchema),
    M.jsonErr(500, errors.InternalServerError$inboundSchema),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}
